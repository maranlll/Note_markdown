# 第三章 处理机调度与死锁

处理机调度的层次：

1.高级调度：
又称为作业调度或长程调度。在批处理系统中，用户提交的作业先被存放在磁盘的后备队列中，高级调度用于决定把外存后备队列中的哪些作业调入内存，为它分配必要的资源，并创建进程。批处理中大多数有，分时和实时系统不设置高级调度。频率为几分钟一次。

2.低级调度：
又称为进程调度或短程调度，用来决定就绪队列中哪个进程先获得处理机，并将处理机分配给选中的进程，让它投入运行。各类操作系统中都有，几十毫秒运行一次。
进程调度方式：
1.非抢占方式：获得 CPU 后一直执行，直到完成或因发生某事件阻塞，才将 CPU 分配给其他进程。
2.抢占方式：当一进程在处理机上执行时，系统可以根据某种原则暂停他的执行，并将已分给他的处理机重新分配给另一进程。
抢占的原则：
1.优先权原则：就绪的高优先级进程有权抢占低优先级进程。
2.短作业优先原则：就绪的短作业（进程）有权抢占长作业（进程）的 CPU。
3.时间片原则：一个时间片用完之后，系统重新进行作业调度。

3.中级调度：又叫做内存调度或中程调度，按一定算法将外存中已具备运行条件的进程换入内存，将内存中处于阻塞状态的某些进程换入外存。目的是解决内存紧张问题，常用在分时系统及有虚拟存储器的系统中，运行频率介于高级调度和低级调度之间。

先来先服务（first-come first-served, FCFS）：
按作业到达的先后顺序进行调度

短作业优先（short job first, SJF）:
作业运行所需时间越短，优先级越高

优先级调度算法（priority-scheduling algorithm, PSA）：
对于 FCFS，作业的等待时间就是作业的优先级，对于 SJF，作业的长短就是作业的优先级。
有静态优先权和动态优先权两种

高响应比优先调度算法（Highest Response Ratio Next, HRRN）：
响应比 $R_p = \frac{等待时间 + 要求服务时间}{要求服务时间}$

轮转调度算法（RR）:
系统将所有的就绪队列按 FIFO 规则排成一个队列，将 CPU 分配给队首进程，令其执行一个时间片。当它运行完毕后，又把处理机分配给就绪队列中新的队首进程，如果时间片用完进程仍未完成，将其插入就绪队列队尾。

多级反馈队列调度算法（FB）：
设置了不同优先级的就绪队列，优先级越高的就绪队列时间片越小。
新就绪的进程总是先进入第一级（优先度最高）队列的队尾，按 FCFS 的原则等待调度。轮到该进程执行时，如它能在规定的时间片内完成，则撤离系统。如不能，进入下一级队列队尾。
系统总是调度第一级队列上的进程执行，仅当第一季队列空时，才调度第二级，以此类推。
方式为抢占调度方式。

周转时间 = 作业完成时间 - 作业提交时间
平均周转时间 $ T = \frac{1}{n} [\sum_{i=1}^n T_i]$
带权周转时间 = 作业周转时间/作业实际运行时间（服务时间）
平均带权周转时间 $W = \frac{1}{n} \sum_{i=1}^n \frac{T_i}{T_s}$
响应比 $R_p = \frac{等待时间 + 要求服务时间}{要求服务时间}$

实时调度算法：

1.最早截止时间优先算法(EDF)：
任务的开始截止时间越早，优先级越高。实时就绪任务队列按各任务的截止时间早晚排序。
抢占式：新到达的任务的开始截止时间比正在执行的任务早，立即抢占 CPU。

2.最低松弛度优先算法(LLF)：
松弛度 = 任务必须完成的时间 - 任务本身运行的时间 - 当前时间
松弛度越低，优先级越高，实时任务就绪队列按优先级排序，采用抢占方法，当一任务的最低松弛度为 0 时，它便立即抢占 CPU，以保证它的截止时间要求。

计算机系统中的死锁：
1.竞争不可抢占性资源引起的死锁
2.竞争可消耗资源引起的死锁
3.进程推进顺序不当引起的死锁

死锁的定义：一组进程发生死锁的情况下，这组死锁进程中的每一个进程，都在等待另一个死锁进程所占有的资源。

产生死锁的原因：
1.资源竞争
2.进程推进顺序非法

产生死锁的必要条件：
1.互斥条件：资源被互斥使用
2.请求和保持条件：占有当前资源并等待
3.不剥夺条件：进程已获得的资源，只能在使用完时自行释放，而不能被抢占
4.环路等待条件：存在一个至少包含两个进程的循环等待链。

处理死锁的方法：
1.预防死锁
2.避免死锁
3.检测死锁
4.解除死锁

银行家算法
1.如果$Request_i[j] <= Need[i,j]$，转向步骤（2）；否则认为出错
2.如果$Request_i[j] <= Available[i,j]$，转向步骤（3），否则，表示尚无足够资源，$P_i$ 需等待
3.系统试探着将资源分配给进程 $P_i$，并修改下面数据结构中的值。
Available[j] = Available[j] - Request_i[j]
Allocation[i,j] = Allocation[i,j] + Request_i[j]
Need[i,j] = Need[i,j] - Request_i[j]
4。系统执行安全性算法，检查此次资源分配后系统是否处于安全状态，若安全，才正式将资源分配给进程 $P_i$；否则，将本次试探分配作废，恢复原来的资源分配状态，让进程 $P_i$ 等待。

安全性算法：
1.设置两个向量：工作向量 work，他表示系统可以提供给进程继续运行所需的各类资源数目，它含有 m 个元素，执行安全性算法时，Work = Available；完成向量 Finish，它表示资源是否有足够的资源分配给进程，开始做时Finish[i] = false。
2.从进程集合中找到一个能满足下述条件的进程：
Finish[i] = false;
Need[i,j] <= Work[j]
若找到，执行步骤（3）；否则，执行步骤（4）
3.当进程 $P_i$获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故执行：
Work[j] = Work[j] + Allocation[i,j]
Finish[i] = true
go to step 2
4.如果所有Finish = true，则表示系统处于安全状态；否则，系统处于不安全状态。

死锁的解除：
1.抢占资源
2.终止（或撤销）进程：
终止进程的方法：
1.终止所有死锁进程
2.逐个终止进程

付出代价最小的死锁解除算法
