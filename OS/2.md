# 第二章 进程的描述与控制

程序的顺序执行的特征：顺序性、封闭性、可再现性
程序的并发执行的特征：间断性、失去封闭性、不可再现性

进程的定义：
进程是程序的一次执行
进程是一个程序及其数据在处理机上顺序执行时所发生的活动
进程是具有独立功能的程序在一个数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位

进程和程序的区别：
1.程序是静态的，进程是动态的
2.进程有并行特征而程序没有
3.进程有资源而程序没有
4.不同的进程可以包含同一程序

进程的特征：
进程具有程序所没有的 PCB 结构
1.动态性
2.并发性
3.独立性
4.异步性
动态性和并发性是最基本的特征

进程的三个基本状态：
1.就绪
2.执行
3.阻塞

就绪 $\rightarrow$ 执行：进程调度
执行 $\rightarrow$ 就绪：时间片完
执行 $\rightarrow$ 阻塞：I/O请求
阻塞 $\rightarrow$ 就绪：I/O完成

4.创建
5.终止

创建 $\rightarrow$ 就绪：许可
执行 $\rightarrow$ 终止：释放

6.挂起：挂起后的进程仍处于就绪状态，它不能参与 CPU 的竞争，处于静止状态
7.激活

执行 $\rightarrow$ 静止就绪：挂起
活动就绪 $\rightarrow$ 静止就绪：挂起
静止就绪 $\rightarrow$ 活动就绪：激活
活动阻塞 $\rightarrow$ 静止阻塞：挂起
静止阻塞 $\rightarrow$ 活动阻塞：激活

进程控制块 PCB 的作用：
1.作为独立运行的基本单位
2.能实现间断性运行方式
3.提供进程管理所需要的信息
4.提供进程调度所需要的信息
5.实现与其他进程的同步与通信

进程控制块中的信息：
1.进程标识符：(1)外部标识符 (2)内部标识符
2.处理机状态
3.进程调度信息：(1)进程状态 (2)进程优先级 (3)进程调度所需的其他信息 (4)事件
4.进程控制信息：(1)程序和数据的地址 (2)进程同步和通信机制 (3)资源清单 (4)链接指针

进程的创建：
1.申请空白 PCB， 为新进程申请获得唯一的数字标识符，并从 PCB 集合中索取一个空白 PCB。
2.为新进程分配其独立运行所需的资源，包括各种物理和逻辑资源，如内存、文件、I/O 设备和 CPU 时间等。
3.初始化进程控制块(PCB)
4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列

进程的约束关系：
1.间接相互制约关系：源于资源共享，无法同时使用同一资源，一进程阻塞。
2.直接相互制约关系：源于进程合作，如输入进程和对应的计算进程

临界资源：在计算机中有许多资源一次只允许一个进程使用，如果多个进程同时使用这些资源，则有可能造成系统的混乱，这些许愿被称为临界资源。
进程间采用互斥关系实现对这种资源的共享。

临界区：人们把在每个进程中访问临界资源的那段代码称为临界区。

同步机制应遵循的规则：
1.空闲让进：临界资源空闲时，允许一个请求进入临界区的进程立刻进入自己的临界区，以便有效的利用资源。
2.忙则等待：当临界资源正被访问时，其他要求进入临界区的进程必须等待，以保证对资源的互斥使用
3.有限等待：任何访问临界资源的进程应能在有限的时间内进入自己的临界区，以免死等。
4.让权等待：不能进入临界区的进程因立即释放 CPU，以免忙等。

整型信号量：
用于表示该类资源的数目，仅能通过两个标准的原子操作来访问：
1.wait(S) 表示申请一个资源，即 P 操作
2.signal(S) 表示释放一个资源， 即 V 操作
```cpp
wait(S){
    while(S <= 0);//忙则等待
    S --;
}
signal(S){
    S ++;
}
```

记录型信号量：
记录型信号量中除了需要一个用于代表该资源数目的整型变量 value， 还增加了一个进程链表指针，用于链接所有等待该资源的进程。
value = 0 表示当前所有资源都在使用，value < 0 时绝对值表示在等待队列中的进程的个数，value > 0 时表示当前可使用的临界资源数。
```cpp
typedef struct{
    int value;
    struct process_control_block *list;
}semaphroe;

wait(semaphroe *S){
    S->value --;
    if(S->value < 0){
        block(S->list);//进入阻塞队列
    }
}
signal(semaphroe *S){
    S->value ++;
    if(S->value <= 0){
        wakeup(S->list);//即使value小于0，但空出了一个资源，可唤醒一个阻塞队列中的进程将其放入就绪队列
    }
}
```

信号量的应用：
1.利用信号量实现前趋关系
2.利用信号量实现互斥

生产者消费者问题：
empty：空闲缓冲区的数目，初始为 n
full：满缓冲区数目，初始为 0
mutex：用于实现缓冲池的互斥访问，初始为 1

```cpp
Producer:
while(true){
    //生产
    P(empty);
    P(mutex);
    //送入缓冲区
    V(mutex);
    V(full);
};

Consumer:
while(true){
    P(full);
    P(mutex);
    //从缓冲区取
    V(mutex);
    V(empty);
}
```

哲学家进餐问题：
```cpp
do{
    wait(chopstick[i]);
    wait(chopstick[(i+1)%5]);
    //eat
    signal(chopstick[i]);
    signal(chopstick[(i+1)%5]);
}while(true);
```

读者-写者问题：
用信号量机制解决读者-写者问题：
读者优先：
```cpp
semaphore mutex = 1, rmutex = 1;//mutex读写的互斥信号量，rmutex是访问readcount的互斥信号量
int readcount = 0;
void read(){
    do{
        //wait(w);读写公平
        wait(rmutex);
        if(readcount == 0){
            wait(mutex);
        }
        readcount ++;
        signal(rmutex);
        //signal(w);读写公平
        //read
        wait(rmutex);
        readcount --;
        if(readcount == 0){
            signal(mutex);
        }
        signal(rmutex);
    }while(true);
}
void write(){
    //wait(w);读写公平
    wait(mutex);
    //write
    signal(mutex);
    //wait(w);读写公平
}
```

管程：由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。 
管程特点：管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。用户编写并发程序如同编写顺序(串行)程序。
（就是一个类，将操作封装了）

进程之间的互斥与同步被结为低级通信。
进程通信：（高级通信）
1.共享存储器系统。指进程之间通过共享存储器的读写来交换数据。
2.管道通信：管道是指连接两个进程的一个共享文件，发送进程以字符串的形式将大量信息写入管道，接收进程在需要时从管道中读出数据。
3.消息传递通信：进程间的数据交换以格式化的消息（报文）为单位。
4.客户机-服务器系统：字套字、远程过程调用和远程方法调用。

线程引入的目的是为了减少程序在并发执行时所付出的时空开销，从而使 OS 具有更好的并发性。

在多线程 OS 中，将拥有资源的基本单位（进程）与调度和分派的基本单位（线程）分开处理。此时，一个进程含有一个或多个相对独立的线程，进程只是拥有资源的基本单位，而不再是一个可执行的实体，每个线程都是一个可执行的实体。

线程的组成：
1.线程标识符
2.程序计数器
3.一组寄存器的值和栈堆

线程的控制：
应用程序在启动时，OS将为它创建一个进程，同时为该选项创建第一个线程。以后在线程的运行过程中，他可根据需要利用线程构造函数再去创造若干个线程。所以线程是由线程创造的，但线程间不提供父子关系的支持。

线程控制块 TCB：
1.线程标识符
2.一组寄存器
3.线程运行状态
4.优先级
5.线程转悠存储区
6.信号屏蔽
7.堆栈指针

线程的实现：
1.内核支持进程
2.用户级线程
3.组合方式

引入进程的目的：使程序能正确地并发，以提高资源利用率和系统吞吐量
引入线程的目的：减少并发执行的开销，提高程序执行的并发程度
线程之所以能减少并发执行的开销是因为线程基本不拥有资源

进程和线程的区别：
1.不同进程的地址空间是独立的，而同一进程内的线程共享同一地址空间，一个进程的线程在另一个进程内是不可见的。
2.在引入线程的操作系统中，进程是资源分配的调度的基本单位，线程是处理机调度和分配的单位，资源是分配给进程的，线程只有很少的资源，因而切换代价比进程切换低
