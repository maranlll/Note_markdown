# 存储器管理


存储器的层次结构
至少为 CPU 寄存器、主存、辅存

层次越高（越靠近 CPU），存储介质的访问速度越快，价格越高，相对配置的存储容量越小。

程序的装入：
1.绝对装入方式：知道程序将驻留在内存的什么位置，编译产生目标模块，绝对装入程序按装入模块的地址将程序和数据装入内存。（系统小，单道）
2.可重定位装入方式（静态重定位）：在装入内存时将装入模块中指令和数据的相对地址调整成相应内存单元的绝对地址，且装入时一次完成以后不再改变。
3.动态运行时装入方式：装入程序在把装入模块装入内存后，并不立即把装入模块的逻辑地址转化为物理地址，把这种地址转化推迟到程序真正要执行时才进行。

程序的链接：
1.静态链接方式：在程序运行前，先将各目标模块及他们所需的库函数链接成一个完整的装配模块，以后不再拆开。事先进行链接
2.装入时动态链接：目标模块装入内存时，采用边装入边链接的链接方式。
3.运行时动态链接：将某些模块的链接推迟到程序执行时进行。目的是为了便于程序在内存中移动

连续分配方式：
1.单一分配方式：内存分为系统区和用户区两部分，用户区仅能存放一道作业。
2.固定分区方式：在系统初启时，将内存的用户空间划分为若干个区域，这些分区的大小和边界在系统运行期间不再变化，并只允许在每个分区装入一道作业。需要建立固定分区说明表，给出起始地址、大小及表示该分区是否已经分配出去的状态信息。
3.动态分区分配：分区大小刚好满足作业的实际需要

基于顺序搜索的动态分区算法：
1.首次适应算法(first fit, FF)：
将空闲分区按起始地址递增的次序排列，每次分配均从空闲分区表或空闲分区链首开始顺序查找，并从第一个能满足要求的空闲分区中划分出作业所要求的空间。
2.循环首次适应算法(next fit, NF)；
建立循环链表，每次查找从上次找到的下一个位置开始查找
3.最佳适应算法(best fit, BF)：
空闲空间按从小到大的顺序形成一空闲分区链，每次寻找满足要求又最小的空闲分区。
4.最坏适应算法(worst fit, WF)：
每次从最大的空闲区中分配一部分储存空间。

基于索引搜索的动态分区分配算法：
1.快速适应算法(quick fit)：
是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样系统中存在多个空闲分区链表。同时，在内存中设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。 
2.伙伴系统(buddy system)：
对于每次分配，二分可分配的最大空间，直到不可再分为止，便将当前大小空分出去，每次二分出的两个空间为伙伴；回收时，如果分区及其伙伴分区都可回收，将其合并形成一个大的分区。
3.哈希算法

离散分配方式：
1.分页存储管理方式
2.分段存储管理方式
3.段页式存储管理方式

分页存储管理方式：

页号从 0 开始。

地址结构：页号 P + 位移量 W（高地址 + 低地址）

页表（页面映射表）：实现从页号到物理块号的地址映射。

页表在内存内，所以每次定位一个位置需要两次访问内存。
使用快表可以实现一次访问到确定位置。

内存的有效访问时间 $EAT$：
不用快表：$2t$
用快表：$a \times \lambda + (t + \lambda)(1-a) + t = 2t + \lambda - t \times a ,(\lambda 为访问快表所需的时间，a 为命中率，t 为访问一次内存所需的时间)$

两级页表：两次映射（32位使用）
多级页表：多级映射（64位使用）

分段式存储管理方式：

分段式存储管理方式更符合用户和程序员的如下需要：
1.方便编程
2.信息共享
3.信息保护
4.动态增长
5.动态链接

分段地址的结构：段号 + 段内地址（高地址 + 低地址）

段表：记录了每一段在内存中的起始地址和段的长度。实现从逻辑段到物理内存区的映射。

段页式存储管理方法：

段页式地址的结构：段号 + 段内页号 + 页内地址（高地址 + 中地址 + 低地址）

系统同时配置段表和页表，段表记录的是页表始址和页表长度。
