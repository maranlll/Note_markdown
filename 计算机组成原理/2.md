## 2.1 数据信息的表示方法

**原码**：最高位为 0 时表示为正数，为 1 时表示为负数。
1）纯小数，设 $x = x_0 . x_1 x_2  \cdots x_{n-1}$，其中 $x_0$ 为符号位，共 n 位字长。
$[x]_原  = \left \{ \begin{aligned} &x &,0 \leqslant x \leqslant 1 - 2^{-(n-1)} \\ &1-x &,-(1 - 2^{-(n-1)}) \leqslant x \leqslant 0 \end{aligned} \right.$


2）纯整数，设 $x = x_0 x_1 x_2 \cdots x_{n-1}$，其中 $x_0$ 为符号位，共 n 位字长。
$[x]_原 = \left \{ \begin{aligned} &x &, 0 \leqslant x \leqslant 2^{n-1} -1\\ & 2^{n-1} - x &, -(2^{n-1} -1) \leqslant x \leqslant 0 \end{aligned}\right.$

$[+0]_原 = 00000000，[-0]_原 = 10000000$

**补码**：除符号位取反加一
1）纯小数时
$[x]_补  = \left \{ \begin{aligned} &x &,0 \leqslant x \leqslant 1 - 2^{-(n-1)} \\ &2+x &, -1 \leqslant x \leqslant 0 \end{aligned} \right.$

2）纯整数时
$[x]_补  = \left \{ \begin{aligned} &x &,0 \leqslant x \leqslant 2^{n-1}-1 \\ &2^n+x &, -2^{n-1} \leqslant x \leqslant 0 \end{aligned} \right.$

$[0]_补 = 00000000$
补码的补码是原码
小数-1：$[-1]_补 = 1.0000000$
整数-1：$[-1]_补 = 11111111$

**反码**：除符号位取反
1）纯小数时
$[x]_补  = \left \{ \begin{aligned} &x &,0 \leqslant x \leqslant 1 - 2^{-(n-1)} \\ &2-2^{-(n-1)}+x &, -1 \leqslant x \leqslant 0 \end{aligned} \right.$

2）纯整数时
$[x]_补  = \left \{ \begin{aligned} &x &,0 \leqslant x \leqslant 2^{n-1}-1 \\ &2^n-1+x &, -2^{n-1} \leqslant x \leqslant 0 \end{aligned} \right.$

**移码**：补码的符号位取反
$[x]_移 = 2^{n-1} + [x]_补$

**定点小数**:
原码范围：
负数：
$1.1111111 \sim 1.0000001, -(1-2^{-7}) \sim -2^{-7}$
正数：
$0.0000001 \sim 0.1111111, 2^{-7} \sim 1-2^{-7}$

补码范围：
负数：
$1.0000000 \sim 1.1111111, -1 \sim -2^{-7}$
正数：
$0.0000001 \sim 0.1111111, 2^{-7} \sim 1-2^{-7}$

**定点整数**：
原码范围：
负数：
$11111111 \sim 1000001, -127 \sim -1$
正数：
$00000001 \sim 01111111, 1 \sim 127$
补码范围：
负数：
$10000000 \sim 11111111, -128 \sim -1$
正数：
$00000001 \sim 01111111, 1 \sim 127$

因为补码 0 唯一，所以补码可以表示 $2^n$ 个数，而原码只能 $2^n-1$ 个数。

**数的浮点表示**：
浮点表示法把字长分为阶码（表示指数）和尾数（表示数值）两部分
阶码 = 阶符 + 阶码值
尾数 = 数符 + 尾数值
设阶码为 E，尾数为D，则 $X = D \times 2^E$。
阶码采用补码或移码定点整数形式、尾数通常用补码定点小数形式。

浮点表示法两种格式：
1.阶符 + 阶码值 + 数符 + 尾数值（阶码为补码）
2.数符 + 阶符 + 阶码值 + 尾数值（阶码为移码）

提高浮点数精度：1.增加尾数尾数 2.浮点数规格化

**浮点数的表示范围**：
1.阶码范围：最小负数：1000（-8），最大负数：1111（-1）， 最小正数：0001（-1），最大正数：0111（8）
2.规格化尾数表示范围：最小负数：1.000（-1），最大负数：1.011（-($2^{-3} + 2^{-1}$)），最小正数：0.100（$2^{-1}$），最大正数：0.111（$1 - 2^{-3}$）
3.规格化浮点数：最小负数：$2^{0111} \times 1.000(-2^7 \times 1)$，最大负数：$2^{1000} \times 1.011(-2^{-8} \times (2^{-3} + 2^{-1}))$，最小正数：$2^{1000} \times 0.100(2^{-8} \times 2^{-1})$，最大正数：$2^{0111} \times 0.111(2^7 \times(1-2^-3))$

**浮点数的规格化**：
通过调整阶码，使尾数满足以下形式：
1.原码规格化：
正数为 $0.1 \times \cdots \times$ 的形式，负数为 $1.1 \times \cdots \times$ 的形式。
2.补码规格化：
正数为 $0.1 \times \cdots \times$ 的形式，负数为 $1.0 \times \cdots \times$ 的形式。

定点数溢出判断是对数值本身进行判断，浮点数是对规格化后的阶码进行判断。但一个浮点数阶码大于机器的最大阶码，称为上溢；小于最小阶码时，称为下溢。机器产生上溢时，不能再继续运算，一般要进行中断处理；出现下溢时，一般规定把浮点数各位强迫为零，机器仍可继续计算。

**IEEE754**：
符号位 S + 指数部分 E + 尾数部分 M
$N = (-1)^S \times 2^{E-127} \times 1.M$
单精度格式（32位）：符号位 1 位， 指数部分 8 位， 尾数部分 23 位。
约定小数点左边隐藏一位 1 。
阶码部分采用偏移码表示，偏移值为 127，因此转原码后阶码需要再减 127。

阶码 255，尾数为 0：无穷大
阶码 255，尾数不为0：非数值 NaN
阶码为 0，尾数为 0：0
阶码为 0，尾数不为 0：非规格化数（0 为隐含位）
正负 0，非规格化数的隐含位为 0，不是 1。

数据校验：
有效信息 k 位 + 校验信息 r 位
码距（海明距离）：同一编码中，任意两个合法编码之间不同二进制位数的最小值（或者异或后数 1 的数目）。
增加冗余项的目的是为了增大码距。
码距与检错或纠错能力的关系：（e 为检错的数目，t 为纠错的数目）
码距 $\geqslant e + 1$，可检测 e 个错误
码距 $\geqslant 2t + 1$ 可纠正 t 个数目
码距 $\geqslant e + t + 1$ 可纠正 t 个数目，同时检测 e 个错误 （e $\geqslant$ t）

码距越大，抗干扰能力越强，纠错能力越强，数据冗余越大，编码效率越低，编码电路也越复杂。

奇偶校验：
有效信息（k位）+ 校验信息（r = 1位）
偶校验：使 1 的个数为偶数个
奇校验：使 1 的个数为奇数个
奇校验检错码：,$G = \overline{C \oplus x_1 \oplus x_2 \oplus x_3 \oplus \cdots \oplus x_n}$，0 表示正常，否则出错
偶校验检错码：,$G = C \oplus x_1 \oplus x_2 \oplus x_3 \oplus \cdots \oplus x_n$，0 表示正常，否则出错
奇偶校验码距为 2
奇偶校验不能检测偶数位错误，无错结论不可靠，无纠错能力

CRC 校验：
有效信息（ k 位）+ 校验信息（ r 位），$N = k + r \leqslant 2^r -1$
选择生成多项式生成冗余码
CRC 校验的检错与纠错：
编码不同数位出错对应不同的余数
CRC 校验无错结论不可信

海明校验：
有效信息（k位）+ 校验信息（r位），$N = k + r \leqslant 2^r -1$
第 i 位校验码 $P_i$ 在第 $2^{i-1}$ 位上。
第 $H_j$ 位的数据被编号小于j的若干个海明位号之和等于 j 的校验位所校验。
由此和宜采用偶校验计算出校验位的值。
当 N = 11 时：
$P_1 = b1 \oplus b2 \oplus b4 \oplus b5 \oplus b7$
$P_2 = b1 \oplus b3 \oplus b4 \oplus b6 \oplus b7$
$P_3 = b2 \oplus b3 \oplus b4$
$P_4 = b5 \oplus b6 \oplus b7$
指错字：
$G_1 = P_1 \oplus b1 \oplus b2 \oplus b4 \oplus b5 \oplus b7$
$G_2 = P_2 \oplus b1 \oplus b3 \oplus b4 \oplus b6 \oplus b7$
$G_3 = P_3 \oplus b2 \oplus b3 \oplus b4$
$G_4 = P_4 \oplus b5 \oplus b6 \oplus b7$
$G_4G_3G_2G_1$ 为 0 则表示无错误，否则表示出错的位数
海明校验无错结论不可信，也无法区别是 1 位错还是 2 位错

## 2.2 定点加、减法运算

$[x]_补 + [y]_补 = [x+y]_补$
$[x]_补 - [y]_补 = [x-y]_补 = [x+(-y)]_补 = [x]_补 + [-y]_补$

$[-y]_补$ 求法为将 $[y]_补$ 包括符号位取反再加一。

补码运算规则：
1.参与运算的数都用补码
2.数据的符号和数据一样都参与运算
3.求差时将减数求补，用求和代替求差
4.运算结果为补码，符号位为 0，正数；符号位为 1，负数
5.符号位的进位若为模值，则应丢掉

溢出判断：
两个符号相同的数相加，其运算结果的符号应与被加数符号相同，两个符号相异的数相减，其运算结果应与被减数符号相同。
判断方法：
1.双符号位法：
00 表示正号
11 表示负号
01表示正向溢出
10表示负向溢出
两位取异或为 1 时有溢出，为 0 时无。
2.进位判断法：
当两个单符号位的补码进行加减运算时，若最高数值位向符号位的进位值 C 与符号位产生的进位输出值 S 相同，则没有溢出，反之则有。即 $V = S \oplus C$

加法器：
![avatar](/计算机组成原理/picture/1.png)
![avatar](/计算机组成原理/picture/2.png)
![avatar](/计算机组成原理/picture/3.png)
![avatar](/计算机组成原理/picture/4.png)
做加法时，P 端信号为 0，$B_i$ 分别送入相应的一位加法器的输入端，实现加法运算；做减法时，P 端信号为 1，$B_i$求反后送入相应的一位加法器的输入端，同时 $C_0 = 1$，即送入加法器的数进行了一次求补操作，经加法器求和就可以实现减法运算。此处溢出判断法为如果最高位进位与符号位异或为 0，则不溢出；异或为 1，则溢出。
![avatar](/计算机组成原理/picture/5.png)
![avatar](/计算机组成原理/picture/6.png)
![avatar](/计算机组成原理/picture/7.png)

## 2.3 定点乘法运算

逻辑左移：数据位整体左移一位，最高位被移出至进位位，最低位补 0
算数左移：数据位整体左移一位，最高位被移出至进位位，最低位补 0
逻辑右移：数据位整体右移一位，最高位补 0，最低位被移出
算术右移：数据位整体右移一位，最高位复制原最高位，最低位被移出

**原码一位乘法运算规则**：$x = x_0x_1x_2\cdots x_n$
（1）被乘数和乘数均取绝对值参与运算，符号位单独考虑
（2）被乘数取双符号，部分积的长度与被乘数的长度相同，初值为 0
（3）从乘数的最低位的 $y_n$ 位开始对乘数进行判断：若 $y_n = 1$，则部分积加上被乘数 |x|，然后右移一位；若 $y_n = 0$，则部分积加上 0，然后右移一位。
（4）重复（3）的判断 n 次。

**补码一位乘法的运算规则**：$x = x_0x_1x_2\cdots x_n$
$[x \cdot y]_补 = [x]_补 \cdot \sum_0^n (y_{i+1} - y_i) 2^{-i}$
（1）符号位参与运算，运算的数均以补码表示
（2）被乘数一般取双符号位参与运算，部分积初值为 0
（3）乘数取可取单符号位，以决定最后一步是否需要校正，即是否需要加 $[-x]_补$
（4）乘数末尾增设附加位 $[y_{n+1}]$，且初值设为 0
（5）如果 $y_{n+1} = y_n$，部分积加 0，部分积算术右移 1 位；如果 $y_{n+1}y_n = 10$，部分积加 $[x]_补$，部分积算术右移 1 位；如果 $y_{n+1}y_n = 01$，部分积加 $[-x]_补$，部分积算术右移 1 位；
（6）重复 n+1 次，第 n+1 次不移位，仅根据 $y_0$ 与 $y_1$ 的比较结果做相应运算即可

![avatar](/计算机组成原理/picture/10.jpg)

**除法补码不恢复余数法**：
1.符号位参与运算，被除数与除数均以双符号位补码表示
2.当被除数与除数同号时，被除数减去除数；异号时加上除数
3.当余数与除数同号时，商上 1，余数左移一位减去除数；反之商上 0，余数左移一位加上除数。
4.采用校正法包括符号位在内，规则 3 重复 n+1 次。
校正：
1.当刚好能除尽时，若除数为正，不用校正，若除数为负，商加 $2^{-n}$
2.当不能除尽时，若商为正，不必校正；若商为负，则商需要加 $2^{-n}$ 进行修正。
在取得 n 位商后，得到的余数往往不正确，若商为正，则当余数与被除数异号时，将余数加上除数进行校正；若商为负，则当余数与被除数异号时，余数减去除数进行校正。

**浮点算术运算：**
加法减法：
1.对阶，首先求出两数的阶码 m 和 n 之差，即 $\delta E = m - n$。对阶操作一般将尾数右移（0 舍 1 入），即阶码增加。
2.尾数相加（相减）
3.结果规格化：尾数符号位为 01 或 10 时，右规；为 00.0 或 11.1时，左规；
4.溢出判断：**阶码**符号位出现 01 或 10 时表示溢出，尾数只指示该如何规范化。

乘法：
阶码相加
尾数相乘

除法：
检查被除数的位数是否小于除数。若小于，则右移一次尾数并将阶码加一。
阶码求差
尾数相除
